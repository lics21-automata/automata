<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Computation (Isabelle2020: April 2020)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Computation</h1>

<span class="command">theory</span> <span class="name">Computation</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Computation</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;xs ys xs&#39; ys&#39;. xs @ ys = xs&#39; @ ys&#39; &#10233; length xs &#8804; length xs&#39; &#10233;
  &#8707;ds. xs&#39; = xs @ ds&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>append_eq_append_conv_if</span><span> </span><span>append_eq_conv_conj</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_app&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;xs ys xs&#39; ys&#39;. xs @ ys = xs&#39; @ ys&#39; &#10233; length xs &#8804; length xs&#39; &#10233;
  &#8707;es. ys = es @ ys&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>append_eq_append_conv_if</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app_decomp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xs = length (ys @ ys&#39;) &#10233;
  &#8707;zs zs&#39;. xs = zs @ zs&#39; &#8743; length zs = length ys &#8743; length zs&#39; = length ys&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_eq_conv_conj</span><span> </span><span>length_drop</span><span> </span><span>length_rev</span><span> </span><span>rev_take</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>singleton_dest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xs = Suc 0 &#10233; &#8707;x. xs = [x]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_zip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set (zip xs ys) &#8838; set xs &#215; set ys&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ys</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>set_zip_leftD</span><span> </span><span>set_zip_rightD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_ext</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map f xs = ys @ ys&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;zs zs&#39;. xs = zs @ zs&#39; &#8743; map f zs = ys &#8743; map f zs&#39; = ys&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>zs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs = take (length ys) xs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>zs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs&#39; = drop (length ys) xs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs = zs @ zs&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map f zs = ys&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map f zs&#39; = ys&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iffD1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>append_eq_conv_conj</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zs_def</span><span> </span><span>zs&#39;_def</span><span> </span><span>take_map</span><span> </span><span>drop_map</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>iter_concat</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; &#39;a list &#8658; &#39;a list&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;iter_concat 0 xs = []&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;iter_concat (Suc n) xs = xs @ iter_concat n xs&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iter_concat_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (iter_concat n xs) = n * length xs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>iter_concat.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_finite_product_subset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;finite Q &#10233; QS&#39; &#8838; Q &#215; Q &#10233; card QS&#39; &#8804; card Q * card Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>card_cartesian_product</span><span> </span><span>card_mono</span><span> </span><span>finite_cartesian_product</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_bounded_lists</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite {bs :: (&#39;b :: finite) list. length bs &#8804; n}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{bs :: &#39;b list. length bs &#8804; Suc n} = {bs. length bs &#8804; n} &#8746; {bs. length bs = Suc n}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{bs :: &#39;b list. length bs = Suc n} &#8838; (&#8899;(b, bs) &#8712; UNIV &#215; {bs. length bs &#8804; n}. {b # bs})&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; {bs :: &#39;b list. length bs = Suc n}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; (&#8899;(b, bs)&#8712;UNIV &#215; {bs. length bs &#8804; n}. {b # bs})&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (&#8899;(b, bs) &#8712; UNIV &#215; {bs :: &#39;b list. length bs &#8804; n}. {b # bs})&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite {bs :: &#39;b list. length bs = Suc n}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>infinite_super</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Suc</span><span> </span><span>split</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* an alphabet extended with a special Blank symbol *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">&#39;a</span><span> </span><span>Al</span><span> </span><span class="delimiter">=</span><span> </span><span>Symb</span><span> </span><span class="tfree">&#39;a</span><span> </span><span class="delimiter">|</span><span> </span><span>Blank</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* safe_hd returns the symbol from the extended alphabet under a reading head
   if the tape consists of a given list of symbols from an alphabet *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd bs&#39; = (case bs&#39; of [] &#8658; Blank | b # bs &#8658; Symb b)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe_hd_Nil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd [] = Blank&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe_hd_Cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd (x # xs) = Symb x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe_hd_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs = xs&#39; @ (q, b) # xs&#39;&#39; &#10233;
  safe_hd (map snd xs) = safe_hd (map snd (xs&#39; @ (q, b) # xs&#39;&#39;&#39;))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons_eq_append_conv</span><span> </span><span>nth_Cons_0</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe_hd_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd xs = safe_hd xs&#39; &#10233; safe_hd (xs @ ys) = safe_hd (xs&#39; @ ys)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe_hd_app&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd ys = safe_hd ys&#39; &#10233; safe_hd (xs @ ys) = safe_hd (xs @ ys&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Nil</span><span> </span><span>hd_append2</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe_hd_app&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs &#8800; [] &#10233; safe_hd (xs @ ys) = safe_hd (xs @ ys&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe_hd_app_Cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd (xs @ x # ys) = safe_hd (xs @ x # ys&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe_hd_Nil_dest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;safe_hd [] = safe_hd xs &#10233; xs = []&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>safe_hd_Cons_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs = x # xs&#39; &#10233; safe_hd (xs @ ys) = Symb x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Definition 2 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>TDFA</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#948;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;a Al &#215; &#39;b Al &#8658; (&#39;s &#215; bool &#215; bool) option&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>accept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; bool&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite Q&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>init_in_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;init &#8712; Q&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>closed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q &#10233; &#948; q z = Some (q&#39;, b1, b2) &#10233; q&#39; &#8712; Q&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>move_left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (a, b) = Some (q&#39;, True, b2) &#10233; a &#8800; Blank&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>move_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (a, b) = Some (q&#39;, b1, True) &#10233; b &#8800; Blank&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (a, b) = Some (q&#39;, False, False) &#10233; False&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* q &#8605;((as, as&#39;), (bs, bs&#39;)) q&#39; iff the automaton has a computation from the state q
   to the state q&#39; with the first tape containing as @ as&#39; and the second tape containing bs @ bs&#39;
   so that the head on the first tape moves past as and the head on the second tape
   moves past bs *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>computation</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; (&#39;a list &#215; &#39;a list) &#215; (&#39;b list &#215; &#39;b list) &#8658; &#39;s &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_/&#8605;_/_&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>base</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(([], as&#39;), ([], bs&#39;)) q&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>step_TT</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (Symb a, Symb b) = Some (q&#39;, True, True) &#10233;
  q&#39; &#8605;((as, as&#39;), (bs, bs&#39;)) q&#39;&#39; &#10233; q &#8605;((a # as, as&#39;), (b # bs, bs&#39;)) q&#39;&#39;&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>step_TF</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (Symb a, safe_hd (bs @ bs&#39;)) = Some (q&#39;, True, False) &#10233;
  q&#39; &#8605;((as, as&#39;), (bs, bs&#39;)) q&#39;&#39; &#10233; q &#8605;((a # as, as&#39;), (bs, bs&#39;)) q&#39;&#39;&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>step_FT</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (safe_hd (as @ as&#39;), Symb b) = Some (q&#39;, False, True) &#10233;
  q&#39; &#8605;((as, as&#39;), (bs, bs&#39;)) q&#39;&#39; &#10233; q &#8605;((as, as&#39;), (b # bs, bs&#39;)) q&#39;&#39;&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* the language computed by the automaton *)</span></span></span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>&#964;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a list &#215; &#39;b list) set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#964; = {(as, bs). &#8707;q. init &#8605;((as, []), (bs, [])) q &#8743; accept q}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_TF_rev</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;((as, a # as&#39;), (bs, bs&#39;)) q&#39; &#10233;
  &#948; q&#39; (Symb a, safe_hd bs&#39;) = Some (q&#39;&#39;, True, False) &#10233; q &#8605;((as @ [a], as&#39;), (bs, bs&#39;)) q&#39;&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((as, a # as&#39;), (bs, bs&#39;))&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_FT_rev</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;((as, as&#39;), (bs, b&#39; # bs&#39;)) q&#39; &#10233;
  &#948; q&#39; (safe_hd as&#39;, Symb b&#39;) = Some (q&#39;&#39;, False, True) &#10233; q &#8605;((as, as&#39;), (bs @ [b&#39;], bs&#39;)) q&#39;&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((as, as&#39;), (bs, b&#39; # bs&#39;))&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_unreachable</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;((as, as&#39;), (bs, bs&#39;)) q&#39; &#10233; (&#8896;z. &#948; q z = None) &#10233; q = q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>computation.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_closed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;((as, as&#39;), (bs, bs&#39;)) q&#39; &#10233; q &#8712; Q &#10233; q&#39; &#8712; Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((as, as&#39;), (bs, bs&#39;))&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>as&#39;</span><span> </span><span>bs</span><span> </span><span>bs&#39;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>closed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_computation_dest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(([], as&#39;), ([], bs&#39;)) q&#39; &#10233; q = q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>computation.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;((as @ as&#39;, as&#39;&#39;), (bs, bs&#39;)) q&#39; &#10233;
  &#8707;q&#39;&#39; cs cs&#39;. bs = cs @ cs&#39; &#8743; q &#8605;((as, as&#39; @ as&#39;&#39;), (cs, cs&#39; @ bs&#39;)) q&#39;&#39; &#8743;
    q&#39;&#39; &#8605;((as&#39;, as&#39;&#39;), (cs&#39;, bs&#39;)) q&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((as @ as&#39;, as&#39;&#39;), (bs, bs&#39;))&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_TT</span><span> </span><span>q</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>q&#39;</span><span> </span><span>as&#39;</span><span> </span><span>bs</span><span> </span><span>q&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>as</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_TT</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>step_TT</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>xs</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Cons</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Cons</span><span> </span><span>computation.step_TT</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_TF</span><span> </span><span>q</span><span> </span><span>a</span><span> </span><span>bs</span><span> </span><span>q&#39;</span><span> </span><span>as</span><span> </span><span>q&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>as</span><span class="delimiter">)</span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_FT</span><span> </span><span>q</span><span> </span><span>b</span><span> </span><span>q&#39;</span><span> </span><span>bs</span><span> </span><span>q&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>as</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_FT</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons_eq_appendI</span><span> </span><span>computation.step_FT</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_pull</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;((u1, u1&#39;), (v1, v1&#39;)) q&#39;&#39; &#10233; q &#8605;((u1 @ u2, u3), (v1 @ v2, v3)) q&#39; &#10233;
  safe_hd u1&#39; = safe_hd (u2 @ u3) &#10233; safe_hd v1&#39; = safe_hd (v2 @ v3) &#10233;
  q&#39;&#39; &#8605;((u2, u3), (v2, v3)) q&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((u1, u1&#39;), (v1, v1&#39;))&quot;</span></span></span><span> </span><span>q&#39;&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>u1</span><span> </span><span>v1</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_TT</span><span> </span><span>q</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>q&#39;&#39;&#39;</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>q&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39;&#39;&#39; &#8605;((as @ u2, u3), bs @ v2, v3) q&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_TT</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>computation.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>step_TT</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>step_TT</span><span class="delimiter">(</span><span>5</span><span class="delimiter">,</span><span>6</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_TF</span><span> </span><span>q</span><span> </span><span>a</span><span> </span><span>bs</span><span> </span><span>q&#39;&#39;&#39;</span><span> </span><span>as</span><span> </span><span>q&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39;&#39;&#39; &#8605;((as @ u2, u3), bs @ v2, v3) q&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_TF</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>safe_hd_Cons_app</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs @ v2&quot;</span></span></span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>v3</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>safe_hd_app&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step_TF</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>safe_hd_Cons</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>computation.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>step_TF</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>step_TF</span><span class="delimiter">(</span><span>5</span><span class="delimiter">,</span><span>6</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_FT</span><span> </span><span>q</span><span> </span><span>as</span><span> </span><span>b</span><span> </span><span>q&#39;&#39;&#39;</span><span> </span><span>bs</span><span> </span><span>q&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39;&#39;&#39;&#8605;((as @ u2, u3), bs @ v2, v3)q&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_FT</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>safe_hd_Cons_app</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;as @ u2&quot;</span></span></span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>u3</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>safe_hd_app&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step_FT</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>safe_hd_Cons</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>computation.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>step_FT</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>step_FT</span><span class="delimiter">(</span><span>5</span><span class="delimiter">,</span><span>6</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_swap</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;((as, a&#39; # as&#39;), (bs, bs&#39;)) q&#39; &#10233; q &#8605;((as, a&#39; # as&#39;&#39;), (bs, bs&#39;)) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((as, a&#39; # as&#39;), (bs, bs&#39;))&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span>
</span><span>      </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>safe_hd_app_Cons</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_swap&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;((as, as&#39;), (bs, b&#39; # bs&#39;)) q&#39; &#10233; q &#8605;((as, as&#39;), (bs, b&#39; # bs&#39;&#39;)) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((as, as&#39;), (bs, b&#39; # bs&#39;))&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span>
</span><span>      </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>safe_hd_app_Cons</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_swap_same_hd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;((as, as&#39;), (bs, bs&#39;)) q&#39; &#10233;
  safe_hd as&#39; = safe_hd as&#39;&#39; &#10233; safe_hd bs&#39; = safe_hd bs&#39;&#39; &#10233;
  q &#8605;((as, as&#39;&#39;), (bs, bs&#39;&#39;)) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((as, as&#39;), (bs, bs&#39;))&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>safe_hd_app&#39;</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;((as, as&#39;), (bs, bs&#39;)) q&#39; &#10233; q&#39; &#8605;((cs, cs&#39;), (ds, ds&#39;)) q&#39;&#39; &#10233;
  safe_hd as&#39; = safe_hd (cs @ cs&#39;) &#10233; safe_hd bs&#39; = safe_hd (ds @ ds&#39;) &#10233;
  q &#8605;((as @ cs, cs&#39;), (bs @ ds, ds&#39;)) q&#39;&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((as, as&#39;), (bs, bs&#39;))&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>safe_hd_app&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>safe_hd_Nil_dest</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_swapR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(([], as&#39;), (bs, bs&#39;)) q&#39; &#10233; q &#8605;(([], as&#39;), (bs, cs&#39;)) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(([] :: &#39;a list, as&#39;), (bs, bs&#39;))&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_transR</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(([], as&#39;), (bs, bs&#39;)) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39; &#8605;(([], as&#39;), (cs, bs&#39;&#39;)) q&#39;&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(([], as&#39;), (bs @ cs, bs&#39;&#39;)) q&#39;&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>comp_swapR</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fst_stepL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#8605;(([], as&#39;), (b # bs, bs&#39;))q&#39; &#10233;
  &#8707;q&#39;&#39;. &#948; q (safe_hd as&#39;, Symb b) = Some (q&#39;&#39;, False, True) &#8743; q&#39;&#39; &#8605;(([], as&#39;), (bs, bs&#39;)) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>computation.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_splitL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#8605;(([], as&#39;), (cs @ cs&#39;, cs&#39;&#39;)) q&#39; &#10233;
  &#8707;q&#39;&#39;. q &#8605;(([], as&#39;), (cs, cs&#39; @ cs&#39;&#39;)) q&#39;&#39; &#8743; q&#39;&#39; &#8605;(([], as&#39;), (cs&#39;, cs&#39;&#39;)) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>cs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>q</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>fst_stepL</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shift_compL</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#8605;(([], w), (cs @ cs&#39;), ds&#39;)t&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8605;((w, []), ds&#39;, [])r&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;t&#39;&#39;. r &#8605;(([], w), (cs, cs&#39; @ ds&#39;)) t&#39;&#39; &#8743; t&#39;&#39; &#8605;((w, []), (cs&#39; @ ds&#39;, [])) r&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t&#39;&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8605;(([], w), (cs, cs&#39; @ ds&#39;)) t&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#39;&#39; &#8605;(([], w), (cs&#39;, ds&#39;)) t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_splitL</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#39;&#39; &#8605;((w, []), (cs&#39; @ ds&#39;, [])) r&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>t&#39;&#39;_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t&#39;&#39;_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>comb</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fst_stepR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#8605;((a # as, as&#39;), ([], bs&#39;))q&#39; &#10233;
  &#8707;q&#39;&#39;. &#948; q (Symb a, safe_hd bs&#39;) = Some (q&#39;&#39;, True, False) &#8743; q&#39;&#39; &#8605;((as, as&#39;), ([], bs&#39;)) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>computation.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>computation_ext</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;s list &#215; (&#39;a list &#215; &#39;a list) &#215; (&#39;b list &#215; &#39;b list) &#8658; &#39;s &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_/&#8605;e_/_&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>base_ext</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e([], ([], as&#39;), ([], bs&#39;)) q&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>step_TT_ext</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (Symb a, Symb b) = Some (q&#39;, True, True) &#10233;
  q&#39; &#8605;e(qs, (as, as&#39;), (bs, bs&#39;)) q&#39;&#39; &#10233; q &#8605;e(q&#39; # qs, (a # as, as&#39;), (b # bs, bs&#39;)) q&#39;&#39;&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>step_TF_ext</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (Symb a, safe_hd (bs @ bs&#39;)) = Some (q&#39;, True, False) &#10233;
  q&#39; &#8605;e(qs, (as, as&#39;), (bs, bs&#39;)) q&#39;&#39; &#10233; q &#8605;e(q&#39; # qs, (a # as, as&#39;), (bs, bs&#39;)) q&#39;&#39;&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>step_FT_ext</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (safe_hd (as @ as&#39;), Symb b) = Some (q&#39;, False, True) &#10233;
  q&#39; &#8605;e(qs, (as, as&#39;), (bs, bs&#39;)) q&#39;&#39; &#10233; q &#8605;e(q&#39; # qs, (as, as&#39;), (b # bs, bs&#39;)) q&#39;&#39;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_to_ext</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;((as, as&#39;), (bs, bs&#39;)) q&#39; &#10233;
  &#8707;qs. q &#8605;e(qs, (as, as&#39;), (bs, bs&#39;)) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((as, as&#39;), (bs, bs&#39;))&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ext_to_comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(qs, (as, as&#39;), (bs, bs&#39;)) q&#39; &#10233; q &#8605;((as, as&#39;), (bs, bs&#39;)) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(qs, (as, as&#39;), (bs, bs&#39;))&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>qs</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation_ext.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ext_closed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(qs, (as, as&#39;), (bs, bs&#39;)) q&#39; &#10233; q &#8712; Q &#10233; set qs &#8838; Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(qs, (as, as&#39;), (bs, bs&#39;))&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>qs</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation_ext.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>closed</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_ext_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(qs, (as, as&#39;), (bs, bs&#39;)) q&#39; &#10233;
  q&#39; &#8605;e(qs&#39;, (cs, cs&#39;), (ds, ds&#39;)) q&#39;&#39; &#10233;
  safe_hd as&#39; = safe_hd (cs @ cs&#39;) &#10233; safe_hd bs&#39; = safe_hd (ds @ ds&#39;) &#10233;
  q &#8605;e(qs @ qs&#39;, (as @ cs, cs&#39;), (bs @ ds, ds&#39;)) q&#39;&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(qs, (as, as&#39;), (bs, bs&#39;))&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>qs</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation_ext.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>safe_hd_app&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>safe_hd_Nil_dest</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_ext_swapR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(qs, ([], as&#39;), (bs, bs&#39;)) q&#39; &#10233; q &#8605;e(qs, ([], as&#39;), (bs, cs&#39;)) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(qs, ([] :: &#39;a list, as&#39;), (bs, bs&#39;))&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>qs</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation_ext.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_ext_transR</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(qs, ([], as&#39;), (bs, bs&#39;)) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39; &#8605;e(qs&#39;, ([], as&#39;), (cs, bs&#39;&#39;)) q&#39;&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(qs @ qs&#39;, ([], as&#39;), (bs @ cs, bs&#39;&#39;)) q&#39;&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_ext_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>comp_ext_swapR</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ext_split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(qs @ q&#39; # qs&#39;, ([], as&#39;), (bs @ b # bs&#39;, bs&#39;&#39;)) q&#39;&#39; &#10233;
  length qs = length bs &#10233;
  q &#8605;e(qs @ [q&#39;], ([], as&#39;), (bs @ [b], bs&#39; @ bs&#39;&#39;)) q&#39; &#8743; q&#39; &#8605;e(qs&#39;, ([], as&#39;), (bs&#39;, bs&#39;&#39;)) q&#39;&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(qs @ q&#39; # qs&#39;,  ([] :: &#39;a list, as&#39;), (bs @ b # bs&#39;, bs&#39;&#39;))&quot;</span></span></span><span> </span><span>q&#39;&#39;</span><span>
</span><span>    </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>qs</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation_ext.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_FT_ext</span><span> </span><span>q</span><span> </span><span>b</span><span> </span><span>q&#39;a</span><span> </span><span>qs</span><span> </span><span>bs</span><span> </span><span>q&#39;&#39;</span><span> </span><span>qsa</span><span> </span><span>bsa</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>qsa</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>bsa</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ext_rem_loop</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(qs @ q&#39; # qs&#39; @ q&#39; # qs&#39;&#39;, ([], as&#39;), (bs @ b # bs&#39; @ b&#39; # bs&#39;&#39;, bs&#39;&#39;&#39;)) q&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;length qs = length bs&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qs&#39; = length bs&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(qs @ q&#39; # qs&#39;&#39;, ([], as&#39;), (bs @ b # bs&#39;&#39;, bs&#39;&#39;&#39;)) q&#39;&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#8605;e(qs @ [q&#39;], ([], as&#39;), bs @ [b], (bs&#39; @ b&#39; # bs&#39;&#39;) @ bs&#39;&#39;&#39;)q&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39; &#8605;e(qs&#39; @ q&#39; # qs&#39;&#39;, ([], as&#39;), bs&#39; @ b&#39; # bs&#39;&#39;, bs&#39;&#39;&#39;)q&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ext_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>split&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39;&#8605;e(qs&#39; @ [q&#39;], ([], as&#39;), bs&#39; @ [b&#39;], bs&#39;&#39; @ bs&#39;&#39;&#39;)q&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39;&#8605;e(qs&#39;&#39;, ([], as&#39;), bs&#39;&#39;, bs&#39;&#39;&#39;)q&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ext_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_ext_transR</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>split&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TDFA in which at most one head moves at any step *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>oTDFA</span><span> </span><span class="delimiter">=</span><span> </span><span>TDFA</span><span> </span><span>init</span><span> </span><span>&#948;</span><span> </span><span>accept</span><span> </span><span>Q</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#948;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;a Al &#215; &#39;b Al &#8658; (&#39;s &#215; bool &#215; bool) option&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>accept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; bool&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s set&quot;</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>move_one</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (a, b) = Some (q&#39;, True, True) &#10233; False&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_ext_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(qs, (as, as&#39;), (bs, bs&#39;)) q&#39; &#10233; length qs = length as + length bs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(qs, (as, as&#39;), (bs, bs&#39;))&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>qs</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation_ext.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>move_one</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fst_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;((a # as, as&#39;), (b # bs, bs&#39;)) q&#39; &#10233;
  (&#8707;q&#39;&#39;. &#948; q (Symb a, Symb b) = Some (q&#39;&#39;, True, False) &#8743; q&#39;&#39; &#8605;((as, as&#39;), (b # bs, bs&#39;)) q&#39;) &#8744;
  (&#8707;q&#39;&#39;. &#948; q (Symb a, Symb b) = Some (q&#39;&#39;, False, True) &#8743; q&#39;&#39; &#8605;((a # as, as&#39;), (bs, bs&#39;)) q&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>move_one</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>computation.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_outs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;((a # as, as&#39;), (bs, bs&#39;)) q&#39; &#10233;
  &#8707;r r&#39; cs cs&#39;. bs = cs @ cs&#39; &#8743; q &#8605;(([], a # as @ as&#39;), (cs, cs&#39; @ bs&#39;)) r &#8743;
  &#948; r (Symb a, safe_hd (cs&#39; @ bs&#39;)) = Some (r&#39;, True, False) &#8743; r&#39; &#8605;((as, as&#39;), (cs&#39;, bs&#39;)) q&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>bs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fst_stepR</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>b</span><span> </span><span>bs&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fst_step</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;q&#39;&#39;. &#948; q (Symb a, Symb b) = Some (q&#39;&#39;, True, False) &#8743;
      q&#39;&#39;&#8605;((as, as&#39;), b # bs&#39;&#39;, bs&#39;)q&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>r&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (Symb a, Symb b) = Some (r&#39;, True, False)&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;r&#39;&#8605;((as, as&#39;), b # bs&#39;&#39;, bs&#39;)q&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;r r&#39; cs cs&#39;. b # bs&#39;&#39; = cs @ cs&#39; &#8743;
      q&#8605;(([], a # as @ as&#39;), cs, cs&#39; @ bs&#39;)r &#8743;
      &#948; r (Symb a, safe_hd (cs&#39; @ bs&#39;)) = Some (r&#39;, True, False) &#8743; r&#39;&#8605;((as, as&#39;), cs&#39;, bs&#39;)q&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>q</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>r&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[]&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>r&#39;_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;q&#39;&#39;. &#948; q (Symb a, Symb b) = Some (q&#39;&#39;, False, True) &#8743;
      q&#39;&#39;&#8605;((a # as, as&#39;), bs&#39;&#39;, bs&#39;)q&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (Symb a, Symb b) = Some (s, False, True)&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8605;((a # as, as&#39;), bs&#39;&#39;, bs&#39;)q&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span>r&#39;</span><span> </span><span>cs</span><span> </span><span>cs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs&#39;&#39; = cs @ cs&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8605;(([], a # as @ as&#39;), cs, cs&#39; @ bs&#39;)r&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; r (Symb a, safe_hd (cs&#39; @ bs&#39;)) = Some (r&#39;, True, False)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#39;&#8605;((as, as&#39;), cs&#39;, bs&#39;)q&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comp_q_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(([], a # as @ as&#39;), ([b], bs&#39;&#39; @ bs&#39;)) s&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>step_FT</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>base</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comp_q_r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(([], a # as @ as&#39;), (b # cs, cs&#39; @ bs&#39;)) r&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>comp_q_s</span><span class="delimiter">]</span><span> </span><span>comp_q_s</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;r r&#39; cs cs&#39;. b # bs&#39;&#39; = cs @ cs&#39; &#8743; q&#8605;(([], a # as @ as&#39;), cs, cs&#39; @ bs&#39;)r &#8743;
      &#948; r (Symb a, safe_hd (cs&#39; @ bs&#39;)) = Some (r&#39;, True, False) &#8743; r&#39;&#8605;((as, as&#39;), cs&#39;, bs&#39;)q&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>r</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>r&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b # cs&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>cs&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>split</span><span> </span><span>comp_q_r</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_zip_upd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xs = length ys &#10233; (&#8896;x y. (x, y) &#8712; set (zip xs ys) &#10233; &#8707;x&#39;. g x&#39; y) &#10233;
  &#8707;xs&#39;. length xs&#39; = length ys &#8743; (&#8704;(x&#39;, y) &#8712; set (zip xs&#39; ys). g x&#39; y)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_induct2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span> </span><span>y</span><span> </span><span>ys</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;g x&#39; y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xs&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xs&#39; = length ys&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;(x&#39;, y) &#8712; set (zip xs&#39; ys). g x&#39; y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x&#39;_def</span><span> </span><span>xs&#39;_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#39; # xs&#39;&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_zip_upd4</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xs = length ys&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;x y z w. (x, y, z, w) &#8712; set (zip xs ys) &#10233; &#8707;x&#39;. g x&#39; y z w) &#10233;
    &#8707;xs&#39;. length xs&#39; = length ys &#8743; (&#8704;(x&#39;, y, z, w) &#8712; set (zip xs&#39; ys). g x&#39; y z w)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set_zip_upd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;x&#39; y. case y of (y&#39;, z, w) &#8658; g x&#39; y&#39; z w&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>split_outss</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;w r r&#39;. (w, r, r&#39;) &#8712; set ws &#10233; r &#8605;((w, []), (u, [])) r&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;cs cs&#39; ts. u = cs @ cs&#39; &#8743; length ts = length ws &#8743;
    (&#8704;(t, w, r, r&#39;) &#8712; set (zip ts ws). r &#8605;(([], w), (cs, cs&#39;)) t &#8743; t &#8605;((w, []), (cs&#39;, [])) r&#39;) &#8743;
    (case concat (map fst ws) of [] &#8658; cs&#39; = [] | _ &#8658; &#8707;a &#8712; set (zip ts ws).
      case a of (t, w, r, r&#39;) &#8658; &#8707;t&#39;. &#948; t (safe_hd w, safe_hd cs&#39;) = Some (t&#39;, True, False))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>ws</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>wrr&#39;</span><span> </span><span>ws</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>w</span><span> </span><span>r</span><span> </span><span>r&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>wrr&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wrr&#39; = (w, r, r&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>wrr&#39;</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cs</span><span> </span><span>cs&#39;</span><span> </span><span>ts</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ws_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u = cs @ cs&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length ts = length ws&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;t w r r&#39;. (t, w, r, r&#39;) &#8712; set (zip ts ws) &#10233;
      r &#8605;(([], w), (cs, cs&#39;)) t &#8743; t &#8605;((w, []), (cs&#39;, [])) r&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;(case concat (map fst ws) of [] &#8658; cs&#39; = [] | _ &#8658; &#8707;a &#8712; set (zip ts ws).
      case a of (t, w, r, r&#39;) &#8658; &#8707;t&#39;. &#948; t (safe_hd w, safe_hd cs&#39;) = Some (t&#39;, True, False))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8605;((w, []), (u, [])) r&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wrr&#39;_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>w</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#8605;(([], []), cs, cs&#39;)t&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8605;(([], []), cs&#39;, [])r&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_splitL</span><span class="delimiter">[</span><span>OF</span><span> </span><span>comp</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>Nil</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>ws_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>concat_map_fst_Nil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;x &#8712; set ws. fst x = []) &#10233; concat (map fst ws) = []&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>one_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;case concat (map fst (wrr&#39; # ws)) of [] &#8658; cs&#39; = []
      | _ &#8658; &#8707;a &#8712; set (zip (t # ts) (wrr&#39; # ws)).
        case a of (t, w, r, r&#39;) &#8658; &#8707;t&#39;. &#948; t (safe_hd w, safe_hd cs&#39;) = Some (t&#39;, True, False)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wrr&#39;_def</span><span> </span><span>Nil</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>concat_map_fst_Nil</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>cs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>cs&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>t_def</span><span> </span><span>one_step</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wrr&#39;_def</span><span> </span><span>Nil</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t # ts&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>as</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span>t&#39;</span><span> </span><span>ds</span><span> </span><span>ds&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u = ds @ ds&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#8605;(([], a # as), ds, ds&#39;)t&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; t (Symb a, safe_hd ds&#39;) = Some (t&#39;, True, False)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#39;&#8605;((as, []), ds&#39;, [])r&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;t&#8605;((a # as, []), ds&#39;, [])r&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_outs</span><span class="delimiter">[</span><span>OF</span><span> </span><span>comp</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>Cons</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length ds &#8804; length cs&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cs&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cs&#39;&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cs = ds @ cs&#39;&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>True</span><span> </span><span>split_app</span><span class="delimiter">[</span><span>of</span><span> </span><span>ds</span><span> </span><span>ds&#39;</span><span> </span><span>cs</span><span> </span><span>cs&#39;</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ds&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ds&#39; = cs&#39;&#39; @ cs&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>cs&#39;&#39;_def</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ts_ts&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;t w r r&#39;. (t, w, r, r&#39;) &#8712; set (zip ts ws) &#10233;
        &#8707;t&#39;&#39;. r &#8605;(([], w), (ds, ds&#39;)) t&#39;&#39; &#8743; t&#39;&#39; &#8605;((w, []), (ds&#39;, [])) r&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>shift_compL</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>ds</span><span> </span><span>cs&#39;&#39;</span><span> </span><span>cs&#39;</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>cs&#39;&#39;_def</span><span> </span><span>ds&#39;_def</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ts&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ts&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length ts&#39; = length ts&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;t w r r&#39;. (t, w, r, r&#39;) &#8712; set (zip ts&#39; ws) &#10233;
          r &#8605;(([], w), (ds, ds&#39;)) t &#8743; t &#8605;((w, []), (ds&#39;, [])) r&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set_zip_upd4</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>ts_ts&#39;</span><span class="delimiter">]</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>ds</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>ds&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ts&#39;_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span> </span><span>ts&#39;_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wrr&#39;_def</span><span> </span><span>Cons</span><span> </span><span>safe_hd_Cons</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t # ts&#39;&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ds&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ds&#39;&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ds = cs @ ds&#39;&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>False</span><span> </span><span>split_app</span><span class="delimiter">[</span><span>of</span><span> </span><span>cs</span><span> </span><span>cs&#39;</span><span> </span><span>ds</span><span> </span><span>ds&#39;</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cs&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cs&#39; = ds&#39;&#39; @ ds&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ds&#39;&#39;_def</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8605;(([], a # as), (cs, cs&#39;)) t&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;t&#39; &#8605;((a # as, []), (cs&#39;, [])) r&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>shift_compL</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ds&#39;&#39;_def</span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cs&#39;_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>concat_map_fst_Cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;concat (map fst ws) &#8800; []&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span>cs&#39;_def</span><span> </span><span>ds&#39;&#39;_def</span><span> </span><span>ws_def</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>cs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>cs&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ws_def</span><span> </span><span>t&#39;_def</span><span> </span><span>concat_map_fst_Cons</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wrr&#39;_def</span><span> </span><span>Cons</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#39; # ts&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>first_reaches</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;((us @ us&#39;, us&#39;&#39;), (vs @ vs&#39;, vs&#39;&#39;)) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;us &#8800; [] &#8744; vs &#8800; []&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;ws ws&#39; q&#39;&#39;. vs = ws @ ws&#39; &#8743; ws&#39; &#8800; [] &#8743;
      q &#8605;((us, us&#39; @ us&#39;&#39;), (ws, ws&#39; @ vs&#39; @ vs&#39;&#39;)) q&#39;&#39; &#8743;
      q&#39;&#39; &#8605;((us&#39;, us&#39;&#39;), (ws&#39; @ vs&#39;, vs&#39;&#39;)) q&#39;) &#8744;
    (&#8707;ws ws&#39; q&#39;&#39;. us = ws @ ws&#39; &#8743; ws&#39; &#8800; [] &#8743;
      q &#8605;((ws, ws&#39; @ us&#39; @ us&#39;&#39;), (vs, vs&#39; @ vs&#39;&#39;)) q&#39;&#39; &#8743;
      q&#39;&#39; &#8605;((ws&#39; @ us&#39;, us&#39;&#39;), (vs&#39;, vs&#39;&#39;)) q&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length us + length vs&quot;</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>q</span><span> </span><span>us</span><span> </span><span>vs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>nat_less_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;uss vss q. q &#8605;((uss @ us&#39;, us&#39;&#39;), (vss @ vs&#39;, vs&#39;&#39;)) q&#39; &#10233;
    (uss &#8800; [] &#8744; vss &#8800; []) &#10233; length uss + length vss &lt; length us + length vs &#10233;
    (&#8707;ws ws&#39; q&#39;&#39;. vss = ws @ ws&#39; &#8743; ws&#39; &#8800; [] &#8743;
      q &#8605;((uss, us&#39; @ us&#39;&#39;), (ws, ws&#39; @ vs&#39; @ vs&#39;&#39;)) q&#39;&#39; &#8743;
      q&#39;&#39; &#8605;((us&#39;, us&#39;&#39;), (ws&#39; @ vs&#39;, vs&#39;&#39;)) q&#39;) &#8744;
    (&#8707;ws ws&#39; q&#39;&#39;. uss = ws @ ws&#39; &#8743; ws&#39; &#8800; [] &#8743;
      q &#8605;((ws, ws&#39; @ us&#39; @ us&#39;&#39;), (vss, vs&#39; @ vs&#39;&#39;)) q&#39;&#39; &#8743;
      q&#39;&#39; &#8605;((ws&#39; @ us&#39;, us&#39;&#39;), (vs&#39;, vs&#39;&#39;)) q&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>us</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[]&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Nil</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>u_def</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>u</span><span> </span><span>uss&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>vs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[]&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u_def</span><span> </span><span>Nil</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>v_def</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>v</span><span> </span><span>vss&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>assm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uss&#39; &#8800; [] &#8744; vs &#8800; []&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;us &#8800; [] &#8744; vss&#39; &#8800; []&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u_def</span><span> </span><span>v_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>qm</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>step</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;(&#948; q (Symb u, Symb v) = Some (qm, True, False) &#8743;
          qm &#8605;((uss&#39; @ us&#39;, us&#39;&#39;), (vs @ vs&#39;, vs&#39;&#39;)) q&#39;) &#8744;
        (&#948; q (Symb u, Symb v) = Some (qm, False, True) &#8743;
          qm &#8605;((us @ us&#39;, us&#39;&#39;), (vss&#39; @ vs&#39;, vs&#39;&#39;)) q&#39;)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fst_step</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>u_def</span><span> </span><span>v_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u_def</span><span> </span><span>v_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (Symb u, Symb v) = Some (qm, True, False) &#8743;
          qm &#8605;((uss&#39; @ us&#39;, us&#39;&#39;), (vs @ vs&#39;, vs&#39;&#39;)) q&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lassms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (Symb u, Symb v) = Some (qm, True, False)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;qm &#8605;((uss&#39; @ us&#39;, us&#39;&#39;), (vs @ vs&#39;, vs&#39;&#39;)) q&#39;&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;ws ws&#39; q&#39;&#39;. vs = ws @ ws&#39; &#8743; ws&#39; &#8800; [] &#8743;
            q&#8605;((us, us&#39; @ us&#39;&#39;), ws, ws&#39; @ vs&#39; @ vs&#39;&#39;)q&#39;&#39; &#8743;
            q&#39;&#39;&#8605;((us&#39;, us&#39;&#39;), ws&#39; @ vs&#39;, vs&#39;&#39;)q&#39;) &#8744;
          (&#8707;ws ws&#39; q&#39;&#39;. us = ws @ ws&#39; &#8743; ws&#39; &#8800; [] &#8743;
            q&#8605;((ws, ws&#39; @ us&#39; @ us&#39;&#39;), vs, vs&#39; @ vs&#39;&#39;)q&#39;&#39; &#8743;
            q&#39;&#39;&#8605;((ws&#39; @ us&#39;, us&#39;&#39;), vs&#39;, vs&#39;&#39;)q&#39;)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lassms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assm</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>u_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI1</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lassms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ws</span><span> </span><span>ws&#39;</span><span> </span><span>q&#39;&#39;</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>ws</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>ws&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>q&#39;&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>step_TF</span><span class="delimiter">)</span><span>
</span><span>               </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>v_def</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Cons</span><span> </span><span>append_assoc</span><span> </span><span>list.inject</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI2</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lassms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u_def</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ws</span><span> </span><span>ws&#39;</span><span> </span><span>q&#39;&#39;</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u # ws&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>ws&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u_def</span><span> </span><span>v_def</span><span> </span><span>safe_hd_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>q&#39;&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (Symb u, Symb v) = Some (qm, False, True) &#8743;
          qm&#8605;((us @ us&#39;, us&#39;&#39;), vss&#39; @ vs&#39;, vs&#39;&#39;)q&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lassms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (Symb u, Symb v) = Some (qm, False, True)&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;qm&#8605;((us @ us&#39;, us&#39;&#39;), vss&#39; @ vs&#39;, vs&#39;&#39;)q&#39;&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;ws ws&#39; q&#39;&#39;. vs = ws @ ws&#39; &#8743; ws&#39; &#8800; [] &#8743;
            q&#8605;((us, us&#39; @ us&#39;&#39;), ws, ws&#39; @ vs&#39; @ vs&#39;&#39;)q&#39;&#39; &#8743;
            q&#39;&#39;&#8605;((us&#39;, us&#39;&#39;), ws&#39; @ vs&#39;, vs&#39;&#39;)q&#39;) &#8744;
          (&#8707;ws ws&#39; q&#39;&#39;. us = ws @ ws&#39; &#8743; ws&#39; &#8800; [] &#8743;
            q&#8605;((ws, ws&#39; @ us&#39; @ us&#39;&#39;), vs, vs&#39; @ vs&#39;&#39;)q&#39;&#39; &#8743;
            q&#39;&#39;&#8605;((ws&#39; @ us&#39;, us&#39;&#39;), vs&#39;, vs&#39;&#39;)q&#39;)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lassms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assm</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>v_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI1</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lassms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ws</span><span> </span><span>ws&#39;</span><span> </span><span>q&#39;&#39;</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;v # ws&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>ws&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u_def</span><span> </span><span>v_def</span><span> </span><span>safe_hd_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>q&#39;&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI2</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lassms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>u_def</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ws</span><span> </span><span>ws&#39;</span><span> </span><span>q&#39;&#39;</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>ws</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>ws&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>v_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>q&#39;&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>step_FT</span><span class="delimiter">)</span><span>
</span><span>               </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Cons</span><span> </span><span>append_assoc</span><span> </span><span>list.inject</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_to_states</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(([], as&#39;), (bs, bs&#39;)) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;qs. length qs = Suc (length bs) &#8743; qs ! 0 = q &#8743;
  (qs ! (length bs)) &#8605;(([], as&#39;), ([], bs&#39;)) q&#39; &#8743; set qs &#8838; Q &#8743;
  (&#8704;i &lt; length bs. &#948; (qs ! i) (safe_hd as&#39;, Symb (bs ! i)) = Some (qs ! (Suc i), False, True))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>bs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[q]&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>b</span><span> </span><span>bs&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>q&#39;&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (safe_hd as&#39;, Symb b) = Some (q&#39;&#39;, False, True)&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39;&#39; &#8605;(([], as&#39;), (bs&#39;&#39;, bs&#39;)) q&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fst_stepL</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>q&#39;&#39;_Q</span><span> </span><span class="delimiter">=</span><span> </span><span>closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>q&#39;&#39;_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>qs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>qs_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qs = Suc (length bs&#39;&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;qs ! 0 = q&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(qs ! length bs&#39;&#39;) &#8605;(([], as&#39;), ([], bs&#39;)) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set qs &#8838; Q&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;i. i &lt; length bs&#39;&#39; &#10233;
      &#948; (qs ! i) (safe_hd as&#39;, Symb (bs&#39;&#39; ! i)) = Some (qs ! Suc i, False, True)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>q&#39;&#39;_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>q&#39;&#39;_Q</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q # qs&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qs_def</span><span> </span><span>q&#39;&#39;_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>states_to_comp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qs = Suc (length bs) &#8743; qs ! 0 = q &#8743; qs ! (length bs) = q&#39; &#8743; (&#8704;i &lt; length bs.
    &#948; (qs ! i) (safe_hd as&#39;, Symb (bs ! i)) = Some (qs ! (Suc i), False, True))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(([], as&#39;), (bs, bs&#39;)) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>bs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>qs</span><span> </span><span>q&#39;</span><span> </span><span>bs&#39;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>snoc</span><span> </span><span>b</span><span> </span><span>bs&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>qs&#39;&#39;</span><span> </span><span>q&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qs = qs&#39;&#39; @ [q&#39;&#39;]&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qs&#39;&#39; = Suc (length bs&#39;&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snoc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>qs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(([], as&#39;), (bs&#39;&#39;, b # bs&#39;)) (qs ! (length bs&#39;&#39;))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snoc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>qs&#39;&#39;</span><span class="delimiter">]</span><span> </span><span>snoc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>split</span><span> </span><span>nth_append</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; (qs ! (length bs&#39;&#39;)) (safe_hd as&#39;, Symb b) = Some (q&#39;, False, True)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snoc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>step_FT_rev</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>det_comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#8605;((u0, u @ u&#39;&#39;), (v0 @ x, x&#39;))r &#10233; q&#8605;((u0 @ u, u&#39;&#39;), v0 @ v, v&#39;)nr&#39; &#10233;
  &#8707;w w&#39; nr. v = w @ w&#39; &#8743; q&#8605;((u0, u @ u&#39;&#39;), v0 @ w, w&#39; @ v&#39;)nr &#8743; nr&#8605;((u, u&#39;&#39;), (w&#39;, v&#39;))nr&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((u0, u @ u&#39;&#39;), (v0 @ x, x&#39;))&quot;</span></span></span><span> </span><span>r</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>u0</span><span> </span><span>v0</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_TT</span><span> </span><span>q</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>q&#39;</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>q&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>move_one</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_TF</span><span> </span><span>q</span><span> </span><span>a</span><span> </span><span>q&#39;</span><span> </span><span>as</span><span> </span><span>q&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>v0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step_TF</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Nil</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>b</span><span> </span><span>v0&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (Symb a, safe_hd ((v0 @ v) @ v&#39;)) = Some (q&#39;, True, False)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_TF</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Cons</span><span> </span><span>safe_hd_Cons</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>det_comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39;&#8605;((as @ u, u&#39;&#39;), v0 @ v, v&#39;)nr&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>computation.cases</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step_TF</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>safe_hd_Cons</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_TF</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>det_comp</span><span class="delimiter">]</span><span> </span><span>step</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Cons</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_FT</span><span> </span><span>q</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>q&#39;</span><span> </span><span>v0&#39;</span><span> </span><span>r&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>v0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step_FT</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Nil</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>b&#39;</span><span> </span><span>v0&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v0&#39;_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;v0&#39; = v0&#39;&#39; @ x&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_FT</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Cons</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q (safe_hd (a @ u @ u&#39;&#39;), Symb b&#39;) = Some (q&#39;, False, True)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_FT</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Cons</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>det_comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39;&#8605;((a @ u, u&#39;&#39;), v0&#39;&#39; @ v, v&#39;)nr&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>computation.cases</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step_FT</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span>move_one</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Cons</span><span> </span><span>safe_hd_Cons</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append.assoc</span><span> </span><span>option.inject</span><span> </span><span>prod.inject</span><span> </span><span>safe_hd_Cons_app</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_FT</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>v0&#39;_def</span><span> </span><span>det_comp</span><span class="delimiter">]</span><span> </span><span>step</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Cons</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>det_comp_safe</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;init&#8605;((u0 @ u, u&#39;&#39;), v0 @ v, v&#39;)nr&#39; &#10233; init&#8605;((u0, u&#39;), (v0 @ x, x&#39;))r &#10233;
  safe_hd (u @ u&#39;&#39;) = safe_hd u&#39; &#10233;
  &#8707;w w&#39; nr. v = w @ w&#39; &#8743; init&#8605;((u0, u @ u&#39;&#39;), v0 @ w, w&#39; @ v&#39;)nr &#8743; nr&#8605;((u, u&#39;&#39;), (w&#39;, v&#39;))nr&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>det_comp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>comp_swap_same_hd</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* simulation of a general TDFA by an oTDFA *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;s</span><span> </span><span>otdfa_s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s + &#39;s&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>TDFA</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>otdfa_init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s otdfa_s&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_init = Inl init&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>otdfa_delta</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s otdfa_s &#8658; &#39;a Al &#215; &#39;b Al &#8658; (&#39;s otdfa_s &#215; bool &#215; bool) option&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_delta (Inl q) (a, b) = (case &#948; q (a, b) of Some (q&#39;, b1, b2) &#8658;
    if b1 &#8743; b2 then Some (Inr q&#39;, True, False) else Some (Inl q&#39;, b1, b2)
  | _ &#8658; None)&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_delta (Inr q) (a, Symb b) = Some (Inl q, False, True)&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_delta (Inr q) (a, Blank) = None&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>otdfa_accept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s otdfa_s &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_accept q = (case q of Inl q&#39; &#8658; accept q&#39; | _ &#8658; False)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>otdfa_Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s otdfa_s set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_Q = Inl ` Q &#8746; Inr ` Q&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>otdfa_delta_Inr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_delta q z = Some (Inr q&#39;, b1, b2) &#10233;
  &#8707;q&#39;&#39;. q = Inl q&#39;&#39; &#8743; &#948; q&#39;&#39; z = Some (q&#39;, True, True) &#8743; b1 &#8743; &#172;b2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span>z</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>otdfa_delta.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>otdfa_finite_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite otdfa_Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_Q</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>otdfa_Q_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>otdfa_init_in_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_init &#8712; otdfa_Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>init_in_Q</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>otdfa_init_def</span><span> </span><span>otdfa_Q_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>otdfa_closed</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_delta q z = Some (q&#39;, b1, b2)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; otdfa_Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39; &#8712; otdfa_Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span>z</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>otdfa_delta.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>otdfa_Q_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>prod.splits</span><span> </span><span>if_splits</span><span> </span><span>Al.splits</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>closed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>otdfa_move_left</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_delta q (a, b) = Some (q&#39;, True, b2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8800; Blank&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>move_left</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(a, b)&quot;</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>otdfa_delta.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>prod.splits</span><span> </span><span>if_splits</span><span> </span><span>Al.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>otdfa_move_right</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_delta q (a, b) = Some (q&#39;, b1, True)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b &#8800; Blank&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>move_right</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(a, b)&quot;</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>otdfa_delta.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>prod.splits</span><span> </span><span>if_splits</span><span> </span><span>Al.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>otdfa_no_step</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_delta q (a, b) = Some (q&#39;, False, False)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>no_step</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(a, b)&quot;</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>otdfa_delta.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>prod.splits</span><span> </span><span>if_splits</span><span> </span><span>Al.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>otdfa_move_one</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa_delta q (a, b) = Some (q&#39;, True, True)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(a, b)&quot;</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>otdfa_delta.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>prod.splits</span><span> </span><span>if_splits</span><span> </span><span>Al.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>otdfa</span><span class="delimiter">:</span><span> </span><span>oTDFA</span><span> </span><span>otdfa_init</span><span> </span><span>otdfa_delta</span><span> </span><span>otdfa_accept</span><span> </span><span>otdfa_Q</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>otdfa_finite_Q</span><span> </span><span>otdfa_init_in_Q</span><span> </span><span>otdfa_closed</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span>
</span><span>        </span><span>otdfa_move_left</span><span> </span><span>otdfa_move_right</span><span> </span><span>otdfa_no_step</span><span> </span><span>otdfa_move_one</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>6</span><span class="delimiter">]</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tdfa_comp_otdfa</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;((as, as&#39;), (bs, bs&#39;)) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa.computation (Inl q) ((as, as&#39;), (bs, bs&#39;)) (Inl q&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((as, as&#39;), (bs, bs&#39;))&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>as&#39;</span><span> </span><span>bs</span><span> </span><span>bs&#39;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_TT</span><span> </span><span>q</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>q&#39;</span><span> </span><span>as</span><span> </span><span>as&#39;</span><span> </span><span>bs</span><span> </span><span>bs&#39;</span><span> </span><span>q&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>otdfa.computation.intros</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>otdfa.computation.intros</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">,</span><span>
</span><span>        </span><span>rotated</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>step_TT</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>step_TT</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>otdfa_comp_tdfa</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;otdfa.computation r ((as, as&#39;), (bs, bs&#39;)) (Inl q&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;r = Inl q &#8744; (r = Inr q&#39;&#39; &#8743; &#948; q (Symb a, safe_hd (bs @ bs&#39;)) = Some (q&#39;&#39;, True, True))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(if r = Inr q&#39;&#39; then (a # as, as&#39;) else (as, as&#39;), (bs, bs&#39;)) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>r</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((as, as&#39;), (bs, bs&#39;))&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Inl q&#39; :: &#39;s otdfa_s&quot;</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>q</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>q&#39;</span><span> </span><span>a</span><span> </span><span>q&#39;&#39;</span><span>
</span><span>  </span><span>rule</span><span class="delimiter">:</span><span> </span><span>otdfa.computation.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_TT</span><span> </span><span>r</span><span> </span><span>x</span><span> </span><span>b</span><span> </span><span>r&#39;</span><span> </span><span>as</span><span> </span><span>bs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>otdfa_move_one</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step_TT</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_TF</span><span> </span><span>r</span><span> </span><span>x</span><span> </span><span>bs</span><span> </span><span>r&#39;</span><span> </span><span>as</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>r&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Inl</span><span> </span><span>r&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_TF</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>Inl</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>if_splits</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Inr</span><span> </span><span>r&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_TF</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>Inr</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>if_splits</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step_FT</span><span> </span><span>r</span><span> </span><span>as</span><span> </span><span>b</span><span> </span><span>r&#39;</span><span> </span><span>bs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tdfa_otdfa_comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;((as, as&#39;), (bs, bs&#39;)) q&#39; &#10231;
  otdfa.computation (Inl q) ((as, as&#39;), (bs, bs&#39;)) (Inl q&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tdfa_comp_otdfa</span><span> </span><span>otdfa_comp_tdfa</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Inl q&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tdfa_equiv_otdfa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#964; = otdfa.&#964;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>&#964;_def</span><span> </span><span>otdfa.&#964;_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>otdfa_init_def</span><span> </span><span>otdfa_accept_def</span><span> </span><span>tdfa_otdfa_comp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>sum.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* k-valued TDFA *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>kTDFA</span><span> </span><span class="delimiter">=</span><span> </span><span>TDFA</span><span> </span><span>init</span><span> </span><span>&#948;</span><span> </span><span>accept</span><span> </span><span>Q</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#948;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;a Al &#215; &#39;b Al &#8658; (&#39;s &#215; bool &#215; bool) option&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>accept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; bool&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s set&quot;</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>kv</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>kval</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite {bs. (as, bs) &#8712; &#964;}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card {bs. (as, bs) &#8712; &#964;} &#8804; kv&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>distinct_conv_nth&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct xs = (&#8704;i &lt; size xs. &#8704;j &lt; size xs. i &lt; j &#10230; xs ! i &#8800; xs ! j)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_conv_nth</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>nat_neq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_concat_replicate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;length (concat (replicate n xs)) = n * length xs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* k-valued oTDFA *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>koTDFA</span><span> </span><span class="delimiter">=</span><span> </span><span>oTDFA</span><span> </span><span>init</span><span> </span><span>&#948;</span><span> </span><span>accept</span><span> </span><span>Q</span><span> </span><span class="delimiter">+</span><span> </span><span>kTDFA</span><span> </span><span>init</span><span> </span><span>&#948;</span><span> </span><span>accept</span><span> </span><span>Q</span><span> </span><span>kv</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#948;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;a Al &#215; &#39;b Al &#8658; (&#39;s &#215; bool &#215; bool) option&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>accept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>kv</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>loop</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;init &#8605;((as, us), (bs, vs @ vs&#39;)) q&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(([], us), (vs, vs&#39;)) q&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;((us, []), (vs&#39;, [])) qf&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;accept qf&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;vs &#8800; []&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;C = {bs. (as @ us, bs) &#8712; &#964;}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finite_C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite C&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>kval</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>C_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;n. q &#8605;(([], us), (concat (replicate n vs), vs&#39;)) q&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_transR</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Suc</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>safe_hd_concat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;n. n &#8800; 0 &#10233;
    safe_hd (vs @ vs&#39;) = safe_hd (concat (replicate n vs) @ vs&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>vs</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>safe_hd_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Suc_pred</span><span> </span><span>append_Cons</span><span> </span><span>concat.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>list.inject</span><span> </span><span>replicate_Suc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;n. n &#8800; 0 &#10233; init &#8605;((as @ us, []), bs @ concat (replicate n vs) @ vs&#39;, []) qf&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>comp</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>safe_hd_concat</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>in_C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;n. n &#8800; 0 &#10233; bs @ concat (replicate n vs) @ vs&#39; &#8712; C&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>&#964;_def</span><span> </span><span>C_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f = (&#955;n. bs @ concat (replicate n vs) @ vs&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inj f&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inj_def</span><span> </span><span>f_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>length</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>length_concat_replicate</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc kv = card (f ` {Suc 0..&lt;Suc (Suc kv)})&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_vimage_inj</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inj</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f ` {1..&lt;Suc (Suc kv)}&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>inj</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inj_vimage_image_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inj</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; &#8804; card C&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>card_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite_C</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>f_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>kval</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;as @ us&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>C_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>state_bounded</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;init &#8605;((as, us), (bs, vs @ vs&#39;)) q&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(([], us), (vs, vs&#39;)) q&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39; &#8605;((us, []), (vs&#39;, [])) qf&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;accept qf&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length vs &#8804; card Q&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;length vs &#8804; card Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_vs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length vs &#8805; Suc (card Q)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vs_not_Nil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;vs &#8800; []&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>vs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>q_Q</span><span> </span><span class="delimiter">=</span><span> </span><span>comp_closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>init_in_Q</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>qs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>qs_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qs = Suc (length vs)&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;qs ! 0 = q&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(qs ! length vs) &#8605;(([], us), ([], vs&#39;)) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set qs &#8838; Q&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;i. i &lt; length vs &#10233; &#948; (qs ! i) (safe_hd us, Symb (vs ! i)) = Some (qs ! Suc i, False, True)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_to_states</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>q_Q</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>qs&#39;&#39;</span><span> </span><span>q&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>qs_split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qs = qs&#39;&#39; @ [q&#39;&#39;]&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>qs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>set_qs&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set qs&#39;&#39; &#8838; Q&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>qs_def</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>qs_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>card_set_qs</span><span> </span><span class="delimiter">=</span><span> </span><span>card_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite_Q</span><span> </span><span>set_qs&#39;&#39;</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qs&#39;&#39; &#8805; Suc (card (set qs&#39;&#39;))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_set_qs</span><span> </span><span>len_vs</span><span> </span><span>qs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>qs_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; j&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j &lt; length qs&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qs&#39;&#39; ! i = qs&#39;&#39; ! j&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distinct_card</span><span class="delimiter">[</span><span>of</span><span> </span><span>qs&#39;&#39;</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_conv_nth&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ij_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; j&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc j &lt; length qs&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qs ! i = qs ! j&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>qs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>qs_split</span><span> </span><span>nth_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>take_drop_i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;take i vs @ drop i vs = vs&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;take (j - i) (drop i vs) @ drop j vs = drop i vs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ij_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>qs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>smt</span><span> </span><span>append.assoc</span><span> </span><span>append_take_drop_id</span><span> </span><span>le_add_diff_inverse</span><span> </span><span>less_imp_le_nat</span><span> </span><span>same_append_eq</span><span>
</span><span>        </span><span>take_add</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r = qs ! i&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_vs_i_j_i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min (length vs - i) (j - i) = j - i&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ij_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>min_def</span><span> </span><span>qs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comp_q_r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(([], us), (take i vs, drop i vs @ vs&#39;)) r&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>states_to_comp</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;take (Suc i) qs&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ij_def</span><span> </span><span>qs_def</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>qs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>r_def</span><span class="delimiter">)</span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comp_init_r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;init &#8605;((as, us), bs @ take i vs, drop i vs @ vs&#39;) r&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>comp_q_r</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>take_drop_i</span><span> </span><span>append.assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comp_r_r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8605;(([], us), (take (j - i) (drop i vs), drop j vs @ vs&#39;)) r&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>states_to_comp</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;take (Suc (j - i)) (drop i qs)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ij_def</span><span> </span><span>qs_def</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>r_def</span><span> </span><span>qs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>min_vs_i_j_i</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comp_r_q&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8605;(([], us), (drop j vs, vs&#39;)) q&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>states_to_comp</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;drop j qs&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>qs_def</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ij_def</span><span> </span><span>qs_def</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>r_def</span><span> </span><span>qs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comp_r_qf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &#8605;((us, []), drop j vs @ vs&#39;, []) qf&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>comp_r_q&#39;</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;drop j vs @ vs&#39; &#8800; []&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ij_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>qs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>loop</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>comp_r_r</span><span> </span><span>comp_r_qf</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>comp_init_r</span><span> </span><span>ij_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>append.assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>take_drop_i</span><span> </span><span>qs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lin_bounded</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;init &#8605;((as, us), (bs, vs)) q &#10233; q &#8605;((us, []), (vs, [])) qf &#10233;
  accept qf &#10233; length vs &#8804; (length us + 1) * card Q&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>us</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>vs</span><span> </span><span>q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>state_bounded</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>base</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>u</span><span> </span><span>us&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>r</span><span> </span><span>r&#39;</span><span> </span><span>cs</span><span> </span><span>cs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;vs = cs @ cs&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#8605;(([], u # us&#39; @ []), cs, cs&#39; @ [])r&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; r (Symb u, safe_hd (cs&#39; @ [])) = Some (r&#39;, True, False)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#39;&#8605;((us&#39;, []), cs&#39;, [])qf&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_outs</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>split&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#8605;(([], u # us&#39;), cs, cs&#39;)r&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>cs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>init_ext</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;init&#8605;((as @ [u], us&#39;), bs @ cs, cs&#39;)r&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>split&#39;</span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>safe_hd_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>step_TF_rev</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>comp_r_qf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r&#8605;((u # us&#39;, []), cs&#39;, [])qf&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>split</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>_</span><span> </span><span>refl</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>r</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[u]&quot;</span></span></span><span> </span><span>us&#39;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[]&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>step_TF</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>base</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>state_bounded</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>split&#39;</span><span> </span><span>comp_r_qf</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>      </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>init_ext</span><span> </span><span>split</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* longest common prefix of two words *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>lcp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a list &#8658; &#39;a list &#8658; &#39;a list&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;lcp [] _ = []&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lcp _ [] = []&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lcp (a # as) (b # bs) = (if a = b then a # lcp as bs else [])&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>len_lcp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a list &#8658; &#39;a list &#8658; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;len_lcp [] _ = 0&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;len_lcp _ [] = 0&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;len_lcp (a # as) (b # bs) = (if a = b then Suc (len_lcp as bs) else 0)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>len_lcp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;len_lcp as bs = length (lcp as bs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>lcp.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>len_lcp_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;len_lcp as bs &#8804; length as&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;len_lcp as bs &#8804; length bs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>len_lcp.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lcp_drop_len_lcp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lcp as bs @ drop (len_lcp as bs) as = as&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;lcp as bs @ drop (len_lcp as bs) bs = bs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>lcp.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* distance of two words w.r.t. their longest common prefix *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lcp_dist</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a list &#8658; &#39;a list &#8658; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;lcp_dist as bs = length as + length bs - 2 * len_lcp as bs&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lcp_le_min</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;len_lcp v1 v2 &#8804; min (length v1) (length v2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>v1</span><span> </span><span>v2</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>lcp.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lcp_zero</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;len_lcp v1 v2 &#8805; 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lcp_app_le_max</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;len_lcp (v1 @ w1) (v2 @ w2) &#8804; len_lcp v1 v2 + max (length w1) (length w2)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>v1</span><span> </span><span>v2</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>lcp.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>v2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lcp_le_min</span><span> </span><span>trans_le_add1</span><span> </span><span>max.coboundedI1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>v</span><span> </span><span>v1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lcp_le_min</span><span> </span><span>trans_le_add2</span><span> </span><span>max.coboundedI2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lcp_le_sum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;len_lcp v1 v2 &#8804; length v1 + length v2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lcp_le_min</span><span> </span><span>trans_le_add1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lcp_le_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;len_lcp v1 v2 &#8804; len_lcp (v1 @ w1) (v2 @ w2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>v1</span><span> </span><span>v2</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>lcp.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lcp_dist as [] = length as&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lcp_dist [] bs = length bs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>as</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lcp_dist_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lcp_dist_app_le_sum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lcp_dist (v1 @ w1) (v2 @ w2) &#8804; lcp_dist v1 v2 + length w1 + length w2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lcp_le_app</span><span class="delimiter">[</span><span>of</span><span> </span><span>v1</span><span> </span><span>v2</span><span> </span><span>w1</span><span> </span><span>w2</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lcp_dist_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lcp_app_le_max_diff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;2 * len_lcp (v1 @ w1) (v2 @ w2) &#8804;
  2 * len_lcp v1 v2 + length w1 + length w2 +
  max (length w1 - length w2) (length w2 - length w1)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lcp_app_le_max</span><span class="delimiter">[</span><span>of</span><span> </span><span>v1</span><span> </span><span>w1</span><span> </span><span>v2</span><span> </span><span>w2</span><span class="delimiter">]</span><span> </span><span>lcp_app_le_max</span><span class="delimiter">[</span><span>of</span><span> </span><span>v2</span><span> </span><span>w2</span><span> </span><span>v1</span><span> </span><span>w1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lcp_dist_le_app_sum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lcp_dist v1 v2 &#8804;
  lcp_dist (v1 @ w1) (v2 @ w2) +
  max (length w1 - length w2) (length w2 - length w1)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lcp_app_le_max_diff</span><span class="delimiter">[</span><span>of</span><span> </span><span>v1</span><span> </span><span>w1</span><span> </span><span>v2</span><span> </span><span>w2</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lcp_dist_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lcp_dist_same_pref</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lcp_dist (u @ v1) (u @ v2) = lcp_dist v1 v2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lcp_dist_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>u</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lcp_dist [0, 0, 0] [0 :: nat]&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lcp_dist ([0, 0, 0] @ [0]) ([0] @ [0, 0, 0 :: nat])&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lcp_dist ([0, 0, 0] @ [0]) ([0] @ [1, 0, 0 :: nat])&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Definition 3 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>NFT</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#948;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;a :: finite &#8658; &#39;s &#215; &#39;b list &#8658; bool&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>accept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; bool&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>finite_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>finite_&#948;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q &#10233; finite {x. &#948; q a x}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>init_in_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;init &#8712; Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#948;_closed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q &#10233; &#948; q a (q&#39;, bs) &#10233; q&#39; &#8712; Q&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* q &#8605;(as, bs) q&#39; iff the transducer has a computation from the state q
   to the state q&#39; reading as and producing bs *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>computation</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;a list &#215; &#39;b list &#8658; &#39;s &#8658; bool&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_/&#8605;_/_&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>base</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;([], []) q&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>step</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q a (q&#39;, bs) &#10233; q&#39; &#8605;(as, bs&#39;) q&#39;&#39; &#10233; q &#8605;(a # as, bs @ bs&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* the language computed by the transducer *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>&#964;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a list &#215; &#39;b list) set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#964; = {(as, bs). &#8707;q. init &#8605;(as, bs) q &#8743; accept q}&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Definition 7 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bv R &#10231; (&#8704;k. &#8707;t. &#8704;(a1, u1) &#8712; R. &#8704;(a2, u2) &#8712; R.
  lcp_dist a1 a2 &#8804; k &#10230; lcp_dist u1 u2 &#8804; t)&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Lemma 8 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bv R &#10231; (&#8704;k. &#8707;t. &#8704;a b1 b2 u1 u2.
  (a @ b1, u1) &#8712; R &#8743; (a @ b2, u2) &#8712; R &#8743; length b1 + length b2 &#8804; k &#10230; lcp_dist u1 u2 &#8804; t)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>bv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bv R&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;k. &#8707;t. &#8704;a b1 b2 u1 u2.
    (a @ b1, u1) &#8712; R &#8743; (a @ b2, u2) &#8712; R &#8743; length b1 + length b2 &#8804; k &#10230; lcp_dist u1 u2 &#8804; t)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>k</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(a1, a2) &#8712; R &#10233; (u1, u2) &#8712; R &#10233;
      lcp_dist a1 u1 &#8804; k &#10233; lcp_dist a2 u2 &#8804; t&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>u1</span><span> </span><span>u2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bv</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bv_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(a @ b1, u1) &#8712; R &#10233; (a @ b2, u2) &#8712; R &#10233; length b1 + length b2 &#8804; k &#10233;
      lcp_dist b1 b2 &#8804; k&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b1</span><span> </span><span>b2</span><span> </span><span>u1</span><span> </span><span>u2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lcp_dist_app_le_sum</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[]&quot;</span></span></span><span> </span><span>b1</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[]&quot;</span></span></span><span> </span><span>b2</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;t. &#8704;a b1 b2. &#8704;u1 u2.
      (a @ b1, u1) &#8712; R &#8743; (a @ b2, u2) &#8712; R &#8743; length b1 + length b2 &#8804; k &#10230; lcp_dist u1 u2 &#8804; t)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>t</span><span class="delimiter">]</span><span> </span><span>t_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>bv&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;k. &#8707;t. &#8704;a b1 b2. &#8704;u1 u2.
    (a @ b1, u1) &#8712; R &#8743; (a @ b2, u2) &#8712; R &#8743; length b1 + length b2 &#8804; k &#10230; lcp_dist u1 u2 &#8804; t)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bv R&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bv_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>k</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(a @ b1, u1) &#8712; R &#10233; (a @ b2, u2) &#8712; R &#10233;
      length b1 + length b2 &#8804; k &#10233; lcp_dist u1 u2 &#8804; t&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b1</span><span> </span><span>u1</span><span> </span><span>b2</span><span> </span><span>u2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bv&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lcp_dist a2 u2 &#8804; t&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(a1, a2) &#8712; R&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(u1, u2) &#8712; R&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lcp_dist a1 u1 &#8804; k&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>u1</span><span> </span><span>u2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t_def</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lcp a1 u1&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;drop (len_lcp a1 u1) a1&quot;</span></span></span><span> </span><span>a2</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;drop (len_lcp a1 u1) u1&quot;</span></span></span><span> </span><span>u2</span><span class="delimiter">]</span><span> </span><span>that</span><span>
</span><span>        </span><span>len_lcp_le</span><span class="delimiter">[</span><span>of</span><span> </span><span>a1</span><span> </span><span>u1</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lcp_drop_len_lcp</span><span> </span><span>lcp_dist_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;t. &#8704;(a1, a2)&#8712;R. &#8704;(u1, u2)&#8712;R. lcp_dist a1 u1 &#8804; k &#10230; lcp_dist a2 u2 &#8804; t&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>t</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Definition 9 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bvT &#10231; (&#8704;k. &#8707;t. &#8704;q1 q2 f1 f2 a b1 b2 u v1 v2 w1 w2.
  q1 &#8712; Q &#8743; q2 &#8712; Q &#8743; accept f1 &#8743; accept f2 &#8743;
  init &#8605;(a, u @ v1) q1 &#8743; q1 &#8605;(b1, w1) f1 &#8743;
  init &#8605;(a, u @ v2) q2 &#8743; q2 &#8605;(b2, w2) f2 &#8743;
  length b1 + length b2 &#8804; k &#10230; lcp_dist (v1 @ w1) (v2 @ w2) &#8804; t)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>active</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;b list &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;active q bs &#10231; (&#8707;q&#39; as bs&#39;. q &#8605;(as, bs @ bs&#39;) q&#39; &#8743; accept q&#39;)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bounded t &#8801; &#8704;q q&#39; u v v&#39;. q &#8712; Q &#8743; q&#39; &#8712; Q &#8743; init &#8605;(u, v @ v&#39;) q &#8743; active q [] &#8743;
  init &#8605;(u, v) q&#39; &#8743; active q&#39; v&#39; &#10230; length v&#39; &#8804; t&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Definition 11 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bounded_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bounded t &#10231; (&#8704;q1 q2 f1 f2 a b1 b2 u v w1 w2.
  q1 &#8712; Q &#8743; q2 &#8712; Q &#8743; accept f1 &#8743; accept f2 &#8743;
  init &#8605;(a, u @ v) q1 &#8743; q1 &#8605;(b1, w1) f1 &#8743;
  init &#8605;(a, u) q2 &#8743; q2 &#8605;(b2, v @ w2) f2 &#10230; length v &#8804; t)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bounded_def</span><span> </span><span>active_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39; &#10233; as = [] &#10233; bs = [] &#8743; q = q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, bs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>one_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q a (q&#39;, bs) &#10233; q &#8605;([a], bs) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation.step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_dest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;([a], bs) q&#39; &#10233; &#948; q a (q&#39;, bs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;([a], bs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation.cases</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39; &#10233; q&#39; &#8605;(as&#39;, bs&#39;) q&#39;&#39; &#10233; q &#8605;(as @ as&#39;, bs @ bs&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, bs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_snoc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39; &#10233; &#948; q&#39; a (q&#39;&#39;, bs&#39;) &#10233; q &#8605;(as @ [a], bs @ bs&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q&#39; a (q&#39;&#39;, bs&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39; &#8605;([a], bs&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as @ [a], bs @ bs&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as @ as&#39;, bs&#39;&#39;) q&#39; &#10233;
  &#8707;q&#39;&#39; bs bs&#39;. q &#8605;(as, bs) q&#39;&#39; &#8743; q&#39;&#39; &#8605;(as&#39;, bs&#39;) q&#39; &#8743; bs&#39;&#39; = bs @ bs&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as @ as&#39;, bs&#39;&#39;)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>as&#39;</span><span> </span><span>bs&#39;&#39;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>q&#39;</span><span> </span><span>bs</span><span> </span><span>q</span><span> </span><span>a</span><span> </span><span>asa</span><span> </span><span>bs&#39;</span><span> </span><span>q&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>as</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>step</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>xs</span><span> </span><span>as&#39;</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_rev_induct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#8605;(as, bs) q&#39; &#10233;
  (&#8896;q. P q [] [] q) &#10233;
  (&#8896;q a q&#39; bs as bs&#39; q&#39;&#39;. P q as bs q&#39;&#39; &#10233; q&#8605;(as, bs)q&#39;&#39; &#10233; &#948; q&#39;&#39; a (q&#39;, bs&#39;) &#10233;
    P q (as @ [a]) (bs @ bs&#39;) q&#39;) &#10233;
  P q as bs q&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>as</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>q</span><span> </span><span>bs</span><span> </span><span>q&#39;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_step</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>snoc</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q&#39;&#39;</span><span> </span><span>cs</span><span> </span><span>cs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(xs, cs) q&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39;&#39; &#8605;([x], cs&#39;) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs = cs @ cs&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>snoc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P_xs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P q xs cs q&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snoc</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>snoc</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snoc</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>P_xs</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>step_dest</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_closed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39; &#10233; q &#8712; Q &#10233; q&#39; &#8712; Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, bs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>&#948;_closed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* computation relation tracking all intermediate steps in a computation *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>computation_ext</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;a list &#215; (&#39;s &#215; &#39;b list) list &#8658; &#39;s &#8658; bool&quot;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_/&#8605;e_/_&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">,</span><span>64</span><span class="delimiter">]</span><span>63</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>base_ext</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e([], []) q&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>step_ext</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#948; q a (q&#39;, bs) &#10233; q&#39; &#8605;e(as, qs) q&#39;&#39; &#10233; q &#8605;e(a # as, (q&#39;, bs) # qs) q&#39;&#39;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_ext_no_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e([], []) q&#39; &#10233; q = q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>computation_ext.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_ext_Cons_dest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#8605;e(a # as&#39;, qb # qbs&#39;)q&#39; &#10233; &#948; q a qb&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>computation_ext.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_ext_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(as, qs) q&#39; &#10233; q&#39; &#8605;e(as&#39;, qs&#39;) q&#39;&#39; &#10233;
  q &#8605;e(as @ as&#39;, qs @ qs&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, qs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>qs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation_ext.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_ext_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(as, qs) q&#39; &#10233; length qs = length as&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, qs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>qs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation_ext.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_ext_sound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(as, qs) q&#39; &#10233; q &#8605;(as, concat (map snd qs)) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, qs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>qs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation_ext.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_ext_complete</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39; &#10233;
  &#8707;qs. q &#8605;e(as, qs) q&#39; &#8743; bs = concat (map snd qs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, bs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_ext_split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as = length qbs &#10233;
  q &#8605;e(as @ a # as&#39;, qbs @ (q&#39;&#39;, bs) # qbs&#39;) q&#39; &#10233;
  q &#8605;e(as @ [a], qbs @ [(q&#39;&#39;, bs)]) q&#39;&#39; &#8743; q&#39;&#39; &#8605;e(as&#39;, qbs&#39;) q&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>as</span><span> </span><span>qbs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>q</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_induct2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>computation_ext.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_ext_closed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(as, qs) q&#39; &#10233; q &#8712; Q &#10233; (r, bs) &#8712; set qs &#10233; r &#8712; Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, qs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>qs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation_ext.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>&#948;_closed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Definition 6 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>all_trans</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s &#215; &#39;b list) set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;all_trans = {x. &#8707;(q, a) &#8712; (Q &#215; (UNIV :: &#39;a set)). &#948; q a x}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>output_speed</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;output_speed = Max (length ` snd ` all_trans &#8746; {1})&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_trans_finite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite all_trans&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fin_Q_UNIV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (Q &#215; (UNIV :: &#39;a set))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_Q</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;all_trans &#8838; &#8899;((&#955;(q, a). {x. &#948; q a x}) ` (Q &#215; (UNIV :: &#39;a set)))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_trans_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (&#8899;((&#955;(q, a). {x. &#948; q a x}) ` (Q &#215; (UNIV :: &#39;a set))))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fin_Q_UNIV</span><span> </span><span>finite_&#948;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>infinite_super</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_trans_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q &#10233; &#948; q a x &#10233; x &#8712; all_trans&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_trans_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>output_speed_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q &#10233; &#948; q a (q&#39;, bs) &#10233; length bs &#8804; output_speed&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>output_speed_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_trans_finite</span><span> </span><span>all_trans_step</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Max_ge</span><span> </span><span>UnCI</span><span> </span><span>finite.emptyI</span><span> </span><span>finite.insertI</span><span> </span><span>finite_UnI</span><span> </span><span>finite_imageI</span><span> </span><span>image_eqI</span><span> </span><span>snd_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>output_speed_computation</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39; &#10233; q &#8712; Q &#10233;
  length bs &#8804; length as * output_speed&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, bs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>output_speed_step</span><span> </span><span>&#948;_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_le_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>output_speed_ext_computation</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(as, qbs) q&#39; &#10233; q &#8712; Q &#10233; (q&#39;&#39;, bs) &#8712; set qbs &#10233;
  length bs &#8804; output_speed&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, qbs)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>qbs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation_ext.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>output_speed_step</span><span> </span><span>&#948;_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>output_speed_pos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;output_speed &#8805; 1&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (length ` snd ` all_trans &#8746; {1})&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_trans_finite</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Max_ge</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fin</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>1</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>output_speed_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_split_out</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as&#39;&#39;, bs @ bs&#39;) q&#39; &#10233; q &#8712; Q &#10233;
  &#8707;q&#39;&#39; as as&#39; cs cs&#39;. q &#8605;(as, cs) q&#39;&#39; &#8743; q&#39;&#39; &#8605;(as&#39;, cs&#39;) q&#39; &#8743; as&#39;&#39; = as @ as&#39; &#8743;
    bs @ bs&#39; = cs @ cs&#39; &#8743; length cs &#8804; length bs &#8743; length bs - length cs &#8804; output_speed&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>q</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as&#39;&#39;, bs @ bs&#39;)&quot;</span></span></span><span> </span><span>q&#39;</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as&#39;&#39;</span><span> </span><span>bs</span><span> </span><span>bs&#39;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>computation.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>q</span><span> </span><span>a</span><span> </span><span>q&#39;</span><span> </span><span>bsa</span><span> </span><span>as</span><span> </span><span>bsa&#39;</span><span> </span><span>q&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>step</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>length_bsa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length bsa &#8804; output_speed&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>output_speed_step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length bsa &#8804; length bs&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>step</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>bsa&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs = bsa @ bsa&#39;&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_eq_append_conv_if</span><span> </span><span>append_eq_conv_conj</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>4</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span> </span><span>step</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>bsa&#39;&#39;</span><span> </span><span>bs&#39;</span><span class="delimiter">]</span><span> </span><span>&#948;_closed</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>step</span><span> </span><span>length_bsa</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#8605;([], [])q &#8743; q&#8605;(a # as, bsa @ bsa&#39;)q&#39;&#39; &#8743; a # as = [] @ (a # as) &#8743;
      bs @ bs&#39; = [] @ (bsa @ bsa&#39;) &#8743; length [] &#8804; length bs &#8743; length bs - length [] &#8804; output_speed&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation.step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_ext_rem</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(as, qbs&#39; @ (q&#39;, bs) # qbs&#39;&#39; @ (q&#39;, bs&#39;) # qbs&#39;&#39;&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;cs&#39; cs&#39;&#39; cs&#39;&#39;&#39; c&#39; c&#39;&#39; ds&#39; bs&#39;&#39;&#39;.
    q &#8605;(cs&#39; @ c&#39; # cs&#39;&#39;&#39;, ds&#39; @ bs @ bs&#39;&#39;&#39;) q&#39;&#39; &#8743;
    ds&#39; = concat (map snd qbs&#39;) &#8743; bs&#39;&#39;&#39; = concat (map snd qbs&#39;&#39;&#39;) &#8743;
    as = cs&#39; @ c&#39; # cs&#39;&#39; @ c&#39;&#39; # cs&#39;&#39;&#39; &#8743; length cs&#39; = length qbs&#39; &#8743;
    length cs&#39;&#39; = length qbs&#39;&#39; &#8743; length cs&#39;&#39;&#39; = length qbs&#39;&#39;&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>len_as</span><span> </span><span class="delimiter">=</span><span> </span><span>computation_ext_length</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as&#39;</span><span> </span><span>as&#39;&#39;</span><span> </span><span>as&#39;&#39;&#39;</span><span> </span><span>a</span><span> </span><span>a&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>decomp&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;as = as&#39; @ [a] @ as&#39;&#39; @ [a&#39;] @ as&#39;&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as&#39; = length qbs&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;length as&#39;&#39; = length qbs&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as&#39;&#39;&#39; = length qbs&#39;&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>app_decomp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>len_as</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>app_decomp</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[(q&#39;, bs)]&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qbs&#39;&#39; @ [(q&#39;, bs&#39;)] @ qbs&#39;&#39;&#39;&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>        </span><span>app_decomp</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>qbs&#39;&#39;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[(q&#39;, bs&#39;)] @ qbs&#39;&#39;&#39;&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>        </span><span>app_decomp</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[(q&#39;, bs&#39;)]&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qbs&#39;&#39;&#39;&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>        </span><span>singleton_dest</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>assoc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(as&#39; @ a # as&#39;&#39; @ [a&#39;] @ as&#39;&#39;&#39;,
    qbs&#39; @ (q&#39;, bs) # qbs&#39;&#39; @ [(q&#39;, bs&#39;)] @ qbs&#39;&#39;&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>decomp&#39;</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(as&#39; @ [a], qbs&#39; @ [(q&#39;, bs)]) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39;&#8605;e(as&#39;&#39; @ a&#39; # as&#39;&#39;&#39;,
    qbs&#39;&#39; @ (q&#39;, bs&#39;) # qbs&#39;&#39;&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation_ext_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>decomp&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assoc</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>split&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39; &#8605;e(as&#39;&#39;&#39;, qbs&#39;&#39;&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation_ext_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>decomp&#39;</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ds&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ds&#39; = concat (map snd qbs&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>bs&#39;&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs&#39;&#39;&#39; = concat (map snd qbs&#39;&#39;&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as&#39; @ [a], ds&#39; @ bs) q&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation_ext_sound</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ds&#39;_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>trans&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39; &#8605;(as&#39;&#39;&#39;, bs&#39;&#39;&#39;) q&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation_ext_sound</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split&#39;</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bs&#39;&#39;&#39;_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>trans</span><span> </span><span>trans&#39;</span><span class="delimiter">]</span><span> </span><span>decomp&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ds&#39;_def</span><span> </span><span>bs&#39;&#39;&#39;_def</span><span> </span><span>decomp&#39;</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>computation_long_split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39; &#10233; q &#8712; Q &#10233; length as &#8805; 1 + card Q &#10233;
  &#8707;as&#39; bs&#39;. q &#8605;(as&#39;, bs&#39;) q&#39; &#8743; length as&#39; &lt; length as&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assms_comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>qbs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>qbs_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;e(as, qbs) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs = concat (map snd qbs)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation_ext_complete</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms_comp</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>qbs_len</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qbs = length as&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation_ext_length</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assms_len</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as &#8805; 1 + card Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>qs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qs = map fst qbs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>qs_sub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set qs &#8838; Q&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation_ext_closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>qbs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms_comp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qs_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>not_distinct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;distinct qs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;&#172;distinct qs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>contr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct qs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>card_qs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card (set qs) &#8805; 1 + card Q&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distinct_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>contr</span><span class="delimiter">]</span><span> </span><span>assms_len</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qs_def</span><span> </span><span>qbs_len</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_qs</span><span> </span><span>card_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite_Q</span><span> </span><span>qs_sub</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q&#39;&#39;</span><span> </span><span>qs&#39;</span><span> </span><span>qs&#39;&#39;</span><span> </span><span>qs&#39;&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qs = qs&#39; @ [q&#39;&#39;] @ qs&#39;&#39; @ [q&#39;&#39;] @ qs&#39;&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_distinct_decomp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>not_distinct</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>qbs&#39;</span><span> </span><span>qbs&#39;&#39;</span><span> </span><span>qbs&#39;&#39;&#39;</span><span> </span><span>bs</span><span> </span><span>bs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>decomp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qbs = qbs&#39; @ (q&#39;&#39;, bs) # qbs&#39;&#39; @ (q&#39;&#39;, bs&#39;) # qbs&#39;&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_ext</span><span class="delimiter">[</span><span>of</span><span> </span><span>fst</span><span> </span><span>qbs</span><span> </span><span>qs&#39;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[q&#39;&#39;] @ qs&#39;&#39; @ [q&#39;&#39;] @ qs&#39;&#39;&#39;&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span>map_ext</span><span class="delimiter">[</span><span>of</span><span> </span><span>fst</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qs&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[q&#39;&#39;] @ qs&#39;&#39;&#39;&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>qs_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;as&#39; bs&#39;. q &#8605;(as&#39;, bs&#39;) q&#39; &#8743; length as&#39; &lt; length as&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation_ext_rem</span><span class="delimiter">[</span><span>OF</span><span> </span><span>qbs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>decomp</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_norm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39; &#10233; q &#8712; Q &#10233; &#8707;as&#39; bs&#39;. q &#8605;(as&#39;, bs&#39;) q&#39; &#8743; length as&#39; &#8804; card Q&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as&quot;</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>nat_less_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as &#8804; card Q&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as&#39;</span><span> </span><span>bs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>nex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as&#39;, bs&#39;) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as&#39; &lt; length as&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation_long_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pumping</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q &#10233; q &#8605;(iter_concat n as, iter_concat n bs) q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>comp_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>active_comp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;active q&#39; bs &#10233; q &#8605;(as, bs&#39;) q&#39; &#10233; active q (bs&#39; @ bs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_trans</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>active_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>active_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;active q (bs @ bs&#39;) &#10233; active q bs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>active_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>active_extend</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs @ bs&#39;) q&#39; &#10233; active q&#39; bs &#10233; active q bs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>active_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>active_Nil_dest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;active q [] &#10233; q &#8712; Q &#10233;
  &#8707;as bs&#39; q&#39;. q &#8605;(as, bs&#39;) q&#39; &#8743; accept q&#39; &#8743; length as &#8804; card Q &#8743;
    length bs&#39; &#8804; card Q * output_speed&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_norm</span><span> </span><span>output_speed_computation</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>active_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>dual_order.trans</span><span> </span><span>mult_le_mono1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Definition 5; note that a state q is useful iff active q [] holds *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>sg</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;sg = Max ((&#955;q. Inf (length ` {as. &#8707;bs q&#39;. q &#8605;(as, bs) q&#39; &#8743; accept q&#39;})) `
    {q &#8712; Q. active q []})&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sg_le_card</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;active init []&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sg &#8804; card Q&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>Q&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Q&#39; = {q &#8712; Q. active q []}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Q&#39;_props</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite Q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Q&#39; &#8800; {}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_Q</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>init_in_Q</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>active_def</span><span> </span><span>Q&#39;_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;q. q &#8712; Q&#39; &#10233; Inf (length ` {as. &#8707;bs q&#39;. q&#8605;(as, bs)q&#39; &#8743; accept q&#39;}) &#8804; card Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>q</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>in_Q&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>q&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>wit</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#8605;(as, bs)q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;accept q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as &#8804; card Q&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>active_Nil_dest</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Q&#39;_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_as_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as &#8712; length ` {as. &#8707;bs q&#39;. q&#8605;(as, bs)q&#39; &#8743; accept q&#39;}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Inf (length ` {as. &#8707;bs q&#39;. q&#8605;(as, bs)q&#39; &#8743; accept q&#39;}) &#8804; card Q&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>le_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cInf_lower</span><span class="delimiter">[</span><span>OF</span><span> </span><span>len_as_in</span><span class="delimiter">]</span><span> </span><span>wit</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Q&#39;_props</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sg_def</span><span> </span><span>Q&#39;_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>active_Nil_dest_sg</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;active q []&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;as bs&#39; q&#39;. q &#8605;(as, bs&#39;) q&#39; &#8743; accept q&#39; &#8743; length as &#8804; sg &#8743;
    length bs&#39; &#8804; sg * output_speed&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ass</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ass = length ` {as. &#8707;bs q&#39;. q &#8605;(as, bs) q&#39; &#8743; accept q&#39;}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ass &#8800; {}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ass_def</span><span> </span><span>active_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Inf ass &#8712; ass&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Inf_nat_def1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as</span><span> </span><span>bs</span><span> </span><span>q&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>wit</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;accept q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as = Inf ass&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ass_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Inf ass &#8804; sg&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>finite_Q</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ass_def</span><span> </span><span>sg_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>output_speed_computation</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wit</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mult.commute</span><span> </span><span>order_subst1</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>as</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>bs</span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>q&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>active_dest</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;active q bs&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8712; Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;as bs&#39; q&#39;. q &#8605;(as, bs @ bs&#39;) q&#39; &#8743; accept q&#39; &#8743;
    length bs&#39; &#8804; (1 + sg) * output_speed&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as</span><span> </span><span>bs&#39;</span><span> </span><span>q&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>act</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q &#8605;(as, bs @ bs&#39;) q&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;accept q&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>active_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length bs&#39; &#8805; output_speed&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bs @ bs&#39; = (bs @ take output_speed bs&#39;) @ (drop output_speed bs&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q&#39;&#39;</span><span> </span><span>as&#39;</span><span> </span><span>as&#39;&#39;</span><span> </span><span>cs</span><span> </span><span>cs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#8605;(as&#39;, cs)q&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39;&#39;&#8605;(as&#39;&#39;, cs&#39;)q&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;as = as&#39; @ as&#39;&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(bs @ take output_speed bs&#39;) @ drop output_speed bs&#39; = cs @ cs&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;length cs &#8804; length (bs @ take output_speed bs&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;length (bs @ take output_speed bs&#39;) - length cs &#8804; output_speed&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>computation_split_out</span><span class="delimiter">[</span><span>OF</span><span> </span><span>act</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>app</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ds</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ds_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cs = bs @ ds&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length ds &#8804; output_speed&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span class="delimiter">(</span><span>5</span><span class="delimiter">,</span><span>6</span><span class="delimiter">)</span><span> </span><span>True</span><span> </span><span>split_app</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>app</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>q&#39;&#39;_Q</span><span> </span><span class="delimiter">=</span><span> </span><span>comp_closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>act_q&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;active q&#39;&#39; []&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>act</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>active_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>es</span><span> </span><span>fs</span><span> </span><span>q&#39;&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>es_fs_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q&#39;&#39;&#8605;(es, fs)q&#39;&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;accept q&#39;&#39;&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length es &#8804; sg&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>active_Nil_dest_sg</span><span class="delimiter">[</span><span>OF</span><span> </span><span>act_q&#39;&#39;</span><span> </span><span>q&#39;&#39;_Q</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fs_len</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length fs &#8804; sg * output_speed&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>output_speed_computation</span><span class="delimiter">[</span><span>OF</span><span> </span><span>es_fs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>q&#39;&#39;_Q</span><span class="delimiter">]</span><span> </span><span>es_fs_def</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>dual_order.trans</span><span> </span><span>mult_le_mono1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>split</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ds_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>es_fs_def</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>ds_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>fs_len</span><span> </span><span>es_fs_def</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bounded_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;K &#8804; K&#39; &#10233; bounded K &#10233; bounded K&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bounded_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bounded_dest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bounded K &#10233; init &#8605;(u, v @ v&#39;) q &#10233; active q [] &#10233;
  init &#8605;(u, v) q&#39; &#10233; active q&#39; v&#39; &#10233; length v&#39; &#8804; K&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>comp_closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>init_in_Q</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bounded_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* NFT with bounded trailing with trailing bound t *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>bNFT</span><span> </span><span class="delimiter">=</span><span> </span><span>NFT</span><span> </span><span>init</span><span> </span><span>&#948;</span><span> </span><span>accept</span><span> </span><span>Q</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#948;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;a :: finite &#8658; &#39;s &#215; (&#39;b :: finite) list &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>accept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s set&quot;</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>t</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bounded</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bounded t&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>bounded&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>bounded_dest</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bounded</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Definition 4; k-valued NFT *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>kNFT</span><span> </span><span class="delimiter">=</span><span> </span><span>NFT</span><span> </span><span>init</span><span> </span><span>&#948;</span><span> </span><span>accept</span><span> </span><span>Q</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#948;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;a :: finite &#8658; &#39;s &#215; &#39;b list &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>accept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s set&quot;</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>kv</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>kval</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite {bs. (as, bs) &#8712; &#964;}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card {bs. (as, bs) &#8712; &#964;} &#8804; kv&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Definition 4; functional NFT *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>fNFT</span><span> </span><span class="delimiter">=</span><span> </span><span>NFT</span><span> </span><span>init</span><span> </span><span>&#948;</span><span> </span><span>accept</span><span> </span><span>Q</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#948;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;a :: finite &#8658; &#39;s &#215; &#39;b list &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>accept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s set&quot;</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>functional</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(x, y) &#8712; &#964; &#10233; (x, y&#39;) &#8712; &#964; &#10233; y = y&#39;&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>one_valued</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite {bs. (as, bs) &#8712; &#964;} &#8743; card {bs. (as, bs) &#8712; &#964;} &#8804; 1&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite {bs. (as, bs) &#8712; &#964;} &#8743; card {bs. (as, bs) &#8712; &#964;} &#8804; 1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{bs. (as, bs) &#8712; &#964;} = {}&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>bs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>bs_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, bs) &#8712; &#964;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{bs. (as, bs) &#8712; &#964;} = {bs}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>functional</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bs_def</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bs_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>kNFT</span><span> </span><span>init</span><span> </span><span>&#948;</span><span> </span><span>accept</span><span> </span><span>Q</span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>one_valued</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* unambiguous NFT *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>uNFT</span><span> </span><span class="delimiter">=</span><span> </span><span>NFT</span><span> </span><span>init</span><span> </span><span>&#948;</span><span> </span><span>accept</span><span> </span><span>Q</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#948;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;a :: finite &#8658; &#39;s &#215; &#39;b list &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>accept</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s set&quot;</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>unambiguous</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;init &#8605;e (as, qbs) f &#10233; accept f &#10233;
  init &#8605;e (as, qbs&#39;) f&#39; &#10233; accept f&#39; &#10233; qbs = qbs&#39;&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>functional</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(as, bs) &#8712; &#964; &#10233; (as, bs&#39;) &#8712; &#964; &#10233; bs = bs&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unambiguous</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>&#964;_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>computation_ext_complete</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>fNFT</span><span> </span><span>init</span><span> </span><span>&#948;</span><span> </span><span>accept</span><span> </span><span>Q</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>functional</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>assumption</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>

</div>
</body>
</html>
